                  ЛАБОРАТОРНАЯ РАБОТА № 5
                                ШАБЛОНЫ
  Цель работы - научиться создавать шаблоны функций и шаблоны классов для работы с любыми типами данных без переписывания кода программы.
                  Теоретические сведения
  Шаблоны позволяют использовать одни и те же функции или классы для обработки данных разных типов. Концепция шаблонов может быть использована в двух видах: по отношению к функциям и по отношению к классам.
  Шаблон функции. Шаблон семейства функций (или просто шаблон функции) определяет по - тенциально неограниченное множество родственных функций и имеет следующий вид:
  template <список_параметров_шаблона> определение функции {}
  Здесь угловые скобки являются неотъемлемым элементом определения. Параметр шаблона начинается со служебного слова class, за ним следует идентификатор параметра, который будет использоваться в шаблоне функции вместо имени типа. Например, шаблон функции вычисления суммы двух однотипных аргументов будет определяться так:
  template <class T> /* шаблон функции с одним параметром */
  T summa (T a, T b)	/* параметры функции одного типа, заданного
           параметром шаблона, тот же тип будет и у результата */
  { return a+b;
}
  Генерация кода функции не происходит до тех пор, пока она не будет вызвана в программе, когда по типу фактических параметров функции становится возможным определить тип параметра шаблона. Каждый сгенерированный по шаблону код называется шаблонной функцией, т.е. шаб - лонная функция - это конкретная реализация шаблона функции. При использовании вышеописан - ного шаблона в вызовах
cout << summa (3,	5)	<< endl;
cout << summa (3.1,	5.)	<< endl;
будет сгенерировано две шаблонные функции: одна - для вычисления суммы целых чисел типа int, другая - для вычисления суммы двух вещественных значений типа double. При попытке вызо - ва функции с разнотипными параметрами
cout << summa (3,	5.)	<< endl; /* первый параметр int,
                  второй double */
произойдет ошибка компиляции, потому что тип параметра шаблона при таком вызове определить невозможно.
  Количество параметров шаблона может быть любым, они перечисляются через запятую в уг - ловых скобках после служебного слова template. Например, требуется найти индекс первого ми - нимального элемента в одномерном массиве. Понятно, что тип элементов массива может быть любым, значит, он будет определять параметр шаблона. Но количество элементов в массиве тоже не обязательно будет типа int, оно может быть задано и значением типа char, и значением типа un - signed long. Следовательно, нужен еще один параметр шаблона:
template <class Tdata, class Tnumber> /* Tdata - тип
                  элементов массива,
                  Tnumber - тип индекса */
  Tnumber pos_min (Tdata mas[], Tnumber n) {
Tnumber i, p =	0;
for (i=1; i<n; i++)
     if (mas[i] < mas[p]) p = i;
return p;
}
  Шаблоны функций можно применять ко всем типам данных, для которых определены опера - ции, используемые в теле функции.
  Шаблон класса. Шаблоны классов обычно используются, когда класс является хранилищем данных, например описывает массив, стек или очередь.
  Шаблон семейства классов (просто шаблон класса или параметризованный класс) определя - ется аналогично шаблону функции:
template <список_параметров_шаблона>
определение_класса{};
  Шаблон семейства классов определяет способ построения отдельных классов подобно тому, как класс определяет правила построения и формат отдельных объектов. В определении класса, входящего в шаблон, особую роль играет имя класса. Оно является не именем отдельного класса, а параметризованным именем семейства классов. Компонентные функции параметризованного класса автоматически являются параметризованными. Пример шаблона семейства классов с об - щим именем Array:
template <class Data> class Array
{
private:
      Data *array;
      int size;
public:
      Array(int s =	10)
      {
        size = s;
        array = new Data [s];
      }
      ~Array()
      {
        if (array)
          delete [] array;
      }
      Data& operator[] (int index)
      { return array[index];
      }
};
  Создав параметризованный класс, можно создать конкретную реализацию этого класса, ис - пользуя общую форму:
имя_класса <перечисление_параметров_шаблона> имя_объекта;
  Например, выражение
Array <int> A(100);
создаст объект А как массив из 100 целых чисел типа int, а выражение
Array <double> B;
создаст объект В как массив из 10 вещественных чисел типа double. Создание объекта типа Array означает не только резервирование памяти для данных, но и генерацию набора методов, оперирую - щих данными указанного параметром типа. Имя типа переменной-объекта состоит из имени класса и параметра шаблона: переменная А имеет тип Array<int>, а переменная В - Array<double>.
  При определении компонентной функции шаблона вне описания класса используют следую - щую конструкцию:
template <список_параметров_шаблона>
тип_результата имя_класса <перечисление_параметров_шаблона> ::
имя_функции(список_формальных_параметров) {
тело_функции;
}
  Например, рассмотренный выше шаблон класса Array может быть переписан так:
template <class Data> class Array /* объявление шаблона класса */ {
private:
      Data *array;
      int size;
public:
      Array(int s =	0);
      ~Array();
      Data& operator[] (int index);
};
  /* внешнее определение методов */
template <class Data>
Array<Data> :: Array(int s) {
    size = s;
    array = new Data [s];
}
template <class Data>
Array<Data> :: ~Array() {
    if (array)
      delete [] array;
}
template <class Data>
Data& Array<Data> :: operator[] (int index) {
    return array[index];
}
                       Постановка задачи
  Написать шаблон функции, выполняющей указанные в вариа-тивной части задания действия. Написать программу тестирования шаблонных функций, созданных на основе этого шаблона, с аргументами указанных типов. Разработать шаблон класса, опи-сывающий указанный в вариативной части задания абстрактный тип данных, и написать программу тестирования объектов двух шаблонных классов. Выбор тестируемого метода должен осу-ществляться с помощью меню. Это задание может быть выполнено на трех уровнях сложности:
   низкий. Указанный АТД можно реализовать любым удобным способом;
   средний. Заданный АТД реализовать с помощью указанной структуры хранения;
   повышенный. Создать требуемый АТД с помощью двух структур хранения: векторной и списковой, реализацию оформить в виде шаблонов классов с единым интерфейсом.
                        Варианты заданий
Вариант 18
  Типы аргументов unsigned int и long.
  1. Перестановка элементов второй половины массива в обрат-ном порядке. При нечетном количестве элементов центральный элемент массива не перемещать.
  2. АТД Очередь. Структура хранения - связанный список.
